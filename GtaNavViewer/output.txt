=== RendererGL.h ===
#pragma once
#include <glad/glad.h>
#include <glm/glm.hpp>
#include "RenderMode.h"

class ViewerCamera;

struct DebugLine
{
    float x0, y0, z0;
    float x1, y1, z1;
};


class RendererGL
{
public:
    RendererGL();
    ~RendererGL();

    void Begin(ViewerCamera* cam, RenderMode mode);
    void End();

    void DebugCube(glm::vec3 pos, float scale);

    GLuint GetShader() const { return shader; }
    void DrawGrid();
    void DrawAxisGizmo();
    void DrawAxisGizmoScreen(const ViewerCamera* cam, int screenW, int screenH);

    void DrawTriangleHighlight(glm::vec3 a, glm::vec3 b, glm::vec3 c);
    void drawNavmeshLines(const std::vector<DebugLine>& lines);
private:
    GLuint LoadShader(const char* vs, const char* fs);

    GLuint shader;
    GLuint vaoCube;
    GLuint vboCube;
    GLuint vaoAxis, vboAxis;
    GLuint vaoGrid, vboGrid;
    int gridVertexCount = 0;

};


=== RendererGL.cpp ===
#include "RendererGL.h"
#include "ViewerCamera.h"

#define GLM_ENABLE_EXPERIMENTAL
#include <glad/glad.h>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtx/euler_angles.hpp>
#include <cstdio>
#include <vector>

static const char* VERT_SRC = R"(
#version 330 core
layout (location = 0) in vec3 aPos;

uniform mat4 uProj;
uniform mat4 uView;
uniform mat4 uModel;

out vec3 vWorldPos;

void main()
{
    vec4 world = uModel * vec4(aPos,1);
    vWorldPos = world.xyz;
    gl_Position = uProj * uView * world;
}

)";


static const char* FRAG_SRC = R"(
#version 330 core

in vec3 vWorldPos;

uniform int uRenderMode;
uniform vec3 uSolidColor;

out vec4 FragColor;

void main()
{
    // ---- CALCULO DE NORMAL POR FACE (preciso e simples) ----
    vec3 N = normalize(cross(dFdx(vWorldPos), dFdy(vWorldPos)));

    if (uRenderMode == 0) {
        FragColor = vec4(1,1,0,1);
    }
    else if (uRenderMode == 1) {
        FragColor = vec4(0,0,0,1);
    }
    else if (uRenderMode == 2) {
        FragColor = vec4(N*0.5+0.5,1);
    }
    else if (uRenderMode == 3) {
        float depth = gl_FragCoord.z;
        FragColor = vec4(depth,depth,depth,1);
    }
    else if (uRenderMode == 4) {
        // ---- LIT estilo Blender SOLID ----
        vec3 L = normalize(vec3(0.4,1.0,0.2));
        float diff = max(dot(N,L), 0.0);
        vec3 base = vec3(0.8, 0.8, 0.9);
        vec3 col  = base*(0.15 + diff*0.85);
        FragColor = vec4(col,1);
    }
    else if (uRenderMode == 99) {
        FragColor = vec4(uSolidColor,1);
    }
}
)";


RendererGL::RendererGL()
{
    shader = LoadShader(VERT_SRC, FRAG_SRC);

    glGenVertexArrays(1, &vaoCube);
    glGenBuffers(1, &vboCube);

    float cubeVerts[] = {
        -1,-1,-1,  1,-1,-1,  1, 1,-1,
        -1,-1,-1,  1, 1,-1, -1, 1,-1,
        -1,-1, 1,  1,-1, 1,  1, 1, 1,
        -1,-1, 1,  1, 1, 1, -1, 1, 1,
        -1,-1,-1, -1, 1,-1, -1, 1, 1,
        -1,-1,-1, -1, 1, 1, -1,-1, 1,
         1,-1,-1,  1, 1,-1,  1, 1, 1,
         1,-1,-1,  1, 1, 1,  1,-1, 1,
        -1,-1,-1,  1,-1,-1,  1,-1, 1,
        -1,-1,-1,  1,-1, 1, -1,-1, 1,
        -1, 1,-1,  1, 1,-1,  1, 1, 1,
        -1, 1,-1,  1, 1, 1, -1, 1, 1
    };

    glBindVertexArray(vaoCube);
    glBindBuffer(GL_ARRAY_BUFFER, vboCube);
    glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVerts), cubeVerts, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3*sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    glBindVertexArray(0);

    float axisVerts[] = {
        // X
        0,0,0,  1,0,0,
        // Y
        0,0,0,  0,1,0,
        // Z
        0,0,0,  0,0,1,
    };

    glGenVertexArrays(1, &vaoAxis);
    glGenBuffers(1, &vboAxis);

    glBindVertexArray(vaoAxis);
    glBindBuffer(GL_ARRAY_BUFFER, vboAxis);
    glBufferData(GL_ARRAY_BUFFER, sizeof(axisVerts), axisVerts, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3*sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    glBindVertexArray(0);

    std::vector<float> grid;
    const int N = 50;

    for (int i=-N; i<=N; i++)
    {
        // Linhas paralelas ao X
        grid.push_back(i); grid.push_back(0); grid.push_back(-N);
        grid.push_back(i); grid.push_back(0); grid.push_back(N);

        // Linhas paralelas ao Z
        grid.push_back(-N); grid.push_back(0); grid.push_back(i);
        grid.push_back(N);  grid.push_back(0); grid.push_back(i);
    }

    gridVertexCount = grid.size() / 3;

    glGenVertexArrays(1, &vaoGrid);
    glGenBuffers(1, &vboGrid);

    glBindVertexArray(vaoGrid);
    glBindBuffer(GL_ARRAY_BUFFER, vboGrid);
    glBufferData(GL_ARRAY_BUFFER, grid.size()*sizeof(float), grid.data(), GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3*sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    glBindVertexArray(0);


}

RendererGL::~RendererGL()
{
    glDeleteProgram(shader);
    glDeleteVertexArrays(1, &vaoCube);
    glDeleteBuffers(1, &vboCube);
}

GLuint RendererGL::LoadShader(const char* vs, const char* fs)
{
    GLuint v = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(v, 1, &vs, NULL);
    glCompileShader(v);

    GLint ok;
    glGetShaderiv(v, GL_COMPILE_STATUS, &ok);
    if (!ok)
    {
        char log[512];
        glGetShaderInfoLog(v, 512, NULL, log);
        printf("[Shader] Vertex error: %s\n", log);
    }

    GLuint f = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(f, 1, &fs, NULL);
    glCompileShader(f);

    glGetShaderiv(f, GL_COMPILE_STATUS, &ok);
    if (!ok)
    {
        char log[512];
        glGetShaderInfoLog(f, 512, NULL, log);
        printf("[Shader] Fragment error: %s\n", log);
    }

    GLuint p = glCreateProgram();
    glAttachShader(p, v);
    glAttachShader(p, f);
    glLinkProgram(p);

    glGetProgramiv(p, GL_LINK_STATUS, &ok);
    if (!ok)
    {
        char log[512];
        glGetProgramInfoLog(p, 512, NULL, log);
        printf("[Shader] Link error: %s\n", log);
    }

    glDeleteShader(v);
    glDeleteShader(f);

    return p;
}

void RendererGL::Begin(ViewerCamera* cam, RenderMode mode)
{
    glUseProgram(shader);
    glUniform1i(glGetUniformLocation(shader, "uRenderMode"), (int)mode);


    // Matriz de projeção e view sempre iguais
    glm::mat4 proj = cam->GetProjMatrix();
    glm::mat4 view = cam->GetViewMatrix();

    glUniformMatrix4fv(glGetUniformLocation(shader, "uProj"), 1, GL_FALSE, &proj[0][0]);
    glUniformMatrix4fv(glGetUniformLocation(shader, "uView"), 1, GL_FALSE, &view[0][0]);

    // Configuração por modo
    switch (mode)
    {
    case RenderMode::Solid:
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        glDisable(GL_POLYGON_OFFSET_FILL);
        break;

    case RenderMode::Wireframe:
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
        glDisable(GL_POLYGON_OFFSET_FILL);
        break;

    case RenderMode::Normals:
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        glDisable(GL_POLYGON_OFFSET_FILL);
        break;

    case RenderMode::Depth:
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        glEnable(GL_POLYGON_OFFSET_FILL);
        glPolygonOffset(1.0f, 1.0f); // evita z-fighting
        break;

    case RenderMode::None:
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        glUniform1i(glGetUniformLocation(shader, "uRenderMode"), 99);
        glUniform3f(glGetUniformLocation(shader, "uSolidColor"), 1,1,1);
        break;


    }
}


void RendererGL::End()
{
    glBindVertexArray(0);
}

void RendererGL::DebugCube(glm::vec3 pos, float scale)
{
    glUseProgram(shader);

    glm::mat4 model(1.0f);
    model = glm::translate(model, pos);
    model = glm::scale(model, glm::vec3(scale));

    glUniformMatrix4fv(glGetUniformLocation(shader, "uModel"), 1, GL_FALSE, &model[0][0]);

    glBindVertexArray(vaoCube);
    glDrawArrays(GL_TRIANGLES, 0, 36);
}

void RendererGL::DrawAxisGizmo()
{
    glUseProgram(shader);

    glm::mat4 model(1.0f);
    glUniformMatrix4fv(glGetUniformLocation(shader, "uModel"), 1, GL_FALSE, &model[0][0]);

    glBindVertexArray(vaoAxis);

    glLineWidth(3.0f);

    glUniform3f(glGetUniformLocation(shader, "uSolidColor"), 1,0,0); // vermelho
    glDrawArrays(GL_LINES, 0, 2);

    glUniform3f(glGetUniformLocation(shader, "uSolidColor"), 0,1,0); // verde
    glDrawArrays(GL_LINES, 2, 2);

    glUniform3f(glGetUniformLocation(shader, "uSolidColor"), 0,0,1); // azul
    glDrawArrays(GL_LINES, 4, 2);
    
}

void RendererGL::DrawGrid()
{
    glUseProgram(shader);

    glm::mat4 model(1.0f);
    glUniformMatrix4fv(glGetUniformLocation(shader, "uModel"), 1, GL_FALSE, &model[0][0]);

    glUniform3f(glGetUniformLocation(shader, "uSolidColor"), 0.3f, 0.3f, 0.3f);

    glBindVertexArray(vaoGrid);
    glLineWidth(1.0f);
    glDrawArrays(GL_LINES, 0, gridVertexCount);
}

void RendererGL::DrawTriangleHighlight(glm::vec3 a, glm::vec3 b, glm::vec3 c)
{
    glUseProgram(shader);

    glm::mat4 model(1.0f);
    glUniformMatrix4fv(glGetUniformLocation(shader, "uModel"),
                       1, GL_FALSE, &model[0][0]);

    glUniform3f(glGetUniformLocation(shader, "uSolidColor"), 1,1,0);


    float tri[] = {
        a.x,a.y,a.z,
        b.x,b.y,b.z,
        c.x,c.y,c.z
    };

    GLuint vao, vbo;
    glGenVertexArrays(1,&vao);
    glGenBuffers(1,&vbo);

    glBindVertexArray(vao);
    glBindBuffer(GL_ARRAY_BUFFER,vbo);
    glBufferData(GL_ARRAY_BUFFER,sizeof(tri),tri,GL_STATIC_DRAW);

    glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,3*sizeof(float),(void*)0);
    glEnableVertexAttribArray(0);

    glLineWidth(4.0f);
    glDrawArrays(GL_LINE_LOOP,0,3);

    glDeleteBuffers(1,&vbo);
    glDeleteVertexArrays(1,&vao);
}

void RendererGL::DrawAxisGizmoScreen(const ViewerCamera* cam, int screenW, int screenH)
{
    glUseProgram(shader);

    // --- 1. Configurar pequena viewport 100x100 no canto superior direito ---
    int size = 100;

    glViewport(screenW - size - 10, 10, size, size);

    // --- 2. Projeção ortográfica (para overlay) ---
    glm::mat4 proj = glm::ortho(-1.f, 1.f, -1.f, 1.f, 0.1f, 100.f);

    // --- 3. View matrix baseada somente na rotação da câmera ― sem posição ---
    glm::mat4 view = glm::lookAt(
        glm::vec3(0,0,3),  // câmera fixa
        glm::vec3(0,0,0),
        glm::vec3(0,1,0)
    );

    // Rotação = mesma da câmera do jogo
    glm::mat4 rot =
        glm::yawPitchRoll(glm::radians(cam->yaw), glm::radians(cam->pitch), 0.0f);

    view = view * rot;

    glUniformMatrix4fv(glGetUniformLocation(shader,"uProj"),1,GL_FALSE,&proj[0][0]);
    glUniformMatrix4fv(glGetUniformLocation(shader,"uView"),1,GL_FALSE,&view[0][0]);

    glm::mat4 model(1.0f);
    glUniformMatrix4fv(glGetUniformLocation(shader,"uModel"),1,GL_FALSE,&model[0][0]);

    // --- 4. Renderizar eixos ---
    glBindVertexArray(vaoAxis);
    glLineWidth(3.0f);

    glUniform3f(glGetUniformLocation(shader,"uSolidColor"), 1,0,0);
    glDrawArrays(GL_LINES, 0, 2);

    glUniform3f(glGetUniformLocation(shader,"uSolidColor"), 0,1,0);
    glDrawArrays(GL_LINES, 2, 2);

    glUniform3f(glGetUniformLocation(shader,"uSolidColor"), 0,0,1);
    glDrawArrays(GL_LINES, 4, 2);

    // --- 5. Restaurar viewport principal (IMPORTANTÍSSIMO!) ---
    glViewport(0, 0, screenW, screenH);
}

void RendererGL::drawNavmeshLines(const std::vector<DebugLine>& lines)
{
    if (lines.empty()) return;

    glBegin(GL_LINES);
    for (const auto& l : lines)
    {
        glVertex3f(l.x0, l.y0, l.z0);
        glVertex3f(l.x1, l.y1, l.z1);
    }
    glEnd();
}



=== ViewerApp.h ===
// ViewerApp.h
#pragma once
#include <string>
#include <SDL.h>
#include "Mesh.h"
#include "RenderMode.h"
#include "GtaNavAPI.h"
#include "NavMeshData.h"
#include "RendererGL.h"

class ViewerCamera;
class RendererGL;


class ViewerApp
{
public:
    ViewerApp();
    ~ViewerApp();

    bool Init();
    void Run();
    void Shutdown();
    bool buildNavmeshFromCurrentMesh();
    void buildNavmeshDebugLines();

private:
    // SDL
    SDL_Window* window = nullptr;
    SDL_GLContext glContext = nullptr;

    // Controls
    bool running = true;
    bool mouseCaptured = false;

    // Engine components
    ViewerCamera* camera = nullptr;
    RendererGL* renderer = nullptr;
    Mesh* loadedMesh = nullptr;
    RenderMode renderMode = RenderMode::Solid;
    glm::vec3 meshPos = glm::vec3(0, 0, -20);
    glm::vec3 meshRot = glm::vec3(0);
    float     meshScale = 10.0f;
    NavMeshData navData;

    // buffers para desenhar navmesh no renderer
    std::vector<glm::vec3> navMeshTris;
    std::vector<glm::vec3> navMeshLines;
    std::vector<DebugLine> m_navmeshLines; // apenas isso por enquanto



private:
    bool InitSDL();
    bool InitGL();
    bool InitImGui();

    void ProcessEvents();
    void RenderFrame();
};


=== ViewerApp.cpp ===
// ViewerApp.cpp
#include "ViewerApp.h"
#include "ViewerCamera.h"
#include "RendererGL.h"
#include "ObjLoader.h"
#include "Mesh.h"
#include "RenderMode.h"
#include "NavMeshData.h"
#include "GtaNavAPI.h"

#include <glad/glad.h>
#include <SDL.h>
#include <SDL_opengl.h>

#include <imgui.h>
#include <backends/imgui_impl_sdl2.h>
#include <backends/imgui_impl_opengl3.h>

#include <glm/gtc/matrix_transform.hpp>

ViewerApp::ViewerApp()
{
}

ViewerApp::~ViewerApp()
{
}

bool ViewerApp::Init()
{
    if (!InitSDL()) return false;
    if (!InitGL())  return false;
    if (!InitImGui()) return false;

    camera   = new ViewerCamera();
    renderer = new RendererGL();
    loadedMesh = ObjLoader::LoadObj("./undulating.obj");
    if (!loadedMesh)
        printf("Falha ao carregar OBJ!\n");
    navData.Load("mynavmesh.navbin");
    navData.ExtractDebugMesh(navMeshTris, navMeshLines);



    return true;
}

void ViewerApp::Shutdown()
{
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplSDL2_Shutdown();
    ImGui::DestroyContext();

    SDL_GL_DeleteContext(glContext);
    SDL_DestroyWindow(window);
    SDL_Quit();

    delete camera;
    delete renderer;
}

bool ViewerApp::InitSDL()
{
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) != 0)
    {
        SDL_Log("SDL_Init Error: %s", SDL_GetError());
        return false;
    }

    // OpenGL 3.3 Core
    //SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    //SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
    
    //SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);    

    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_COMPATIBILITY);


    window = SDL_CreateWindow(
        "GTA NavMesh Viewer",
        SDL_WINDOWPOS_CENTERED,
        SDL_WINDOWPOS_CENTERED,
        1600, 900,
        SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI
    );

    if (!window)
    {
        SDL_Log("SDL_CreateWindow Error: %s", SDL_GetError());
        return false;
    }

    glContext = SDL_GL_CreateContext(window);
    SDL_GL_MakeCurrent(window, glContext);
    SDL_GL_SetSwapInterval(1); // vsync
    printf("window = %p\n", window);
    printf("glContext = %p\n", glContext);

    return true;
}

bool ViewerApp::InitGL()
{
    if (!gladLoadGLLoader((GLADloadproc)SDL_GL_GetProcAddress))
    {
        SDL_Log("Failed to initialize GLAD");
        return false;
    }

    glViewport(0, 0, 1600, 900);
    glEnable(GL_DEPTH_TEST);
    glDisable(GL_CULL_FACE);
    glDepthFunc(GL_LESS); // já deve ser default, mas garantimos

    return true;
}

bool ViewerApp::InitImGui()
{
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();

    ImGuiIO& io = ImGui::GetIO();

    // POR ENQUANTO: sem docking nem viewports
    // io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;
    // io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;

    ImGui::StyleColorsDark();

    ImGui_ImplSDL2_InitForOpenGL(window, glContext);
    ImGui_ImplOpenGL3_Init("#version 330");

    return true;
}


void ViewerApp::Run()
{
    while (running)
    {
        ProcessEvents();
        RenderFrame();
    }
}

bool RayTriangleIntersect(const Ray& r,
                          const glm::vec3& v0,
                          const glm::vec3& v1,
                          const glm::vec3& v2,
                          float& outDist)
{
    const float EPS = 0.00001f;
    glm::vec3 e1 = v1 - v0;
    glm::vec3 e2 = v2 - v0;

    glm::vec3 p = glm::cross(r.dir, e2);
    float det = glm::dot(e1, p);

    if (fabs(det) < EPS) return false;

    float inv = 1.0f / det;

    glm::vec3 t = r.origin - v0;

    float u = glm::dot(t, p) * inv;
    if (u < 0 || u > 1) return false;

    glm::vec3 q = glm::cross(t, e1);

    float v = glm::dot(r.dir, q) * inv;
    if (v < 0 || u + v > 1) return false;

    float dist = glm::dot(e2, q) * inv;
    if (dist < 0) return false;

    outDist = dist;
    return true;
}

int pickedTri = -1;

void ViewerApp::ProcessEvents()
{
    SDL_Event e;
    while (SDL_PollEvent(&e))
    {
        ImGui_ImplSDL2_ProcessEvent(&e);

        if (e.type == SDL_QUIT)
            running = false;

        if (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_ESCAPE)
            running = false;

        if (e.type == SDL_KEYDOWN)
        {
            switch (e.key.keysym.sym)
            {
            case SDLK_F1:
                renderMode = RenderMode::Solid;
                break;

            case SDLK_F2:
                renderMode = RenderMode::Wireframe;
                break;

            case SDLK_F3:
                renderMode = RenderMode::Normals;
                break;

            case SDLK_F4:
                renderMode = RenderMode::Depth;
                break;
            case SDLK_F5:
                renderMode = RenderMode::Lit;
                break;

            }
        }
        if (e.type == SDL_MOUSEBUTTONDOWN && e.button.button == SDL_BUTTON_LEFT)
        {
            int mx = e.button.x;
            int my = e.button.y;

            Ray ray = camera->GetRayFromScreen(mx, my, 1600, 900);

            // MATRIZ MODEL — EXATA usada no render
            glm::mat4 model(1.0f);
            model = glm::translate(model, meshPos);
            model = glm::rotate(model, glm::radians(meshRot.x), glm::vec3(1,0,0));
            model = glm::rotate(model, glm::radians(meshRot.y), glm::vec3(0,1,0));
            model = glm::rotate(model, glm::radians(meshRot.z), glm::vec3(0,0,1));
            model = glm::scale(model, glm::vec3(meshScale));

            float best = FLT_MAX;
            pickedTri = -1;

            for (int i = 0; i < loadedMesh->indices.size(); i += 3)
            {
                int i0 = loadedMesh->indices[i+0];
                int i1 = loadedMesh->indices[i+1];
                int i2 = loadedMesh->indices[i+2];

                // ****** TRANSFORMAR PARA ESPAÇO MUNDIAL ******
                glm::vec3 v0 = glm::vec3(model * glm::vec4(loadedMesh->vertices[i0], 1.0f));
                glm::vec3 v1 = glm::vec3(model * glm::vec4(loadedMesh->vertices[i1], 1.0f));
                glm::vec3 v2 = glm::vec3(model * glm::vec4(loadedMesh->vertices[i2], 1.0f));

                float dist;
                if (RayTriangleIntersect(ray, v0, v1, v2, dist))
                {
                    if (dist < best)
                    {
                        best = dist;
                        pickedTri = i;
                    }
                }
            }
        }



        // Mouse capture toggle
        if (e.type == SDL_MOUSEBUTTONDOWN && e.button.button == SDL_BUTTON_RIGHT)
        {
            mouseCaptured = true;
            SDL_SetRelativeMouseMode(SDL_TRUE);
        }
        if (e.type == SDL_MOUSEBUTTONUP && e.button.button == SDL_BUTTON_RIGHT)
        {
            mouseCaptured = false;
            SDL_SetRelativeMouseMode(SDL_FALSE);
        }

        if (mouseCaptured)
        {
            if (e.type == SDL_MOUSEMOTION)
                camera->OnMouseMove(e.motion.xrel, e.motion.yrel);
        }
    }

    const Uint8* state = SDL_GetKeyboardState(NULL);
    camera->Update(state);
}

void ViewerApp::RenderFrame()
{
    // --- Iniciar nova frame ImGui ---
    ImGui_ImplOpenGL3_NewFrame();
    ImGui_ImplSDL2_NewFrame();
    ImGui::NewFrame();

    // --- UI: Render Mode ---
    ImGui::Begin("Render Mode");

    int mode = (int)renderMode;
    ImGui::RadioButton("Solid (F1)",     &mode, 0);
    ImGui::RadioButton("Wireframe (F2)", &mode, 1);
    ImGui::RadioButton("Normals (F3)",   &mode, 2);
    ImGui::RadioButton("Depth (F4)",     &mode, 3);
    ImGui::RadioButton("Lit (F5)", &mode, 4);


    renderMode = (RenderMode)mode;

    ImGui::End();


    // --- Debug Camera ---
    ImGui::Begin("Debug");
    ImGui::Text("Camera: %.2f %.2f %.2f",
        camera->pos.x, camera->pos.y, camera->pos.z);
    ImGui::End();

    // --- OpenGL ---
    glEnable(GL_DEPTH_TEST);
    glClearColor(0,1,1,1);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // Begin renderer com renderMode
    renderer->Begin(camera, renderMode);
    glUniform3f(glGetUniformLocation(renderer->GetShader(), "uSolidColor"), 1,1,1);

    // Cubo
    renderer->DebugCube(camera->pos + glm::vec3(0,0,-5), 1.0f);

    // OBJ

    if (loadedMesh)
    {
        ImGui::Begin("Mesh Info");

        ImGui::Text("Mesh bounds:");
        ImGui::Text("Min: %.1f %.1f %.1f",
            loadedMesh->minBounds.x,
            loadedMesh->minBounds.y,
            loadedMesh->minBounds.z);

        ImGui::Text("Max: %.1f %.1f %.1f",
            loadedMesh->maxBounds.x,
            loadedMesh->maxBounds.y,
            loadedMesh->maxBounds.z);

        glm::vec3 center = (loadedMesh->minBounds + loadedMesh->maxBounds) * 0.5f;
        ImGui::Text("Center: %.1f %.1f %.1f",
            center.x, center.y, center.z);

        if (ImGui::Button("Teleport Camera to Mesh Center"))
            camera->pos = center + glm::vec3(0,50,150);

        ImGui::End();

        glm::mat4 model(1.0f);
        model = glm::translate(model, meshPos);
        model = glm::rotate(model, glm::radians(meshRot.x), glm::vec3(1,0,0));
        model = glm::rotate(model, glm::radians(meshRot.y), glm::vec3(0,1,0));
        model = glm::rotate(model, glm::radians(meshRot.z), glm::vec3(0,0,1));
        model = glm::scale(model, glm::vec3(meshScale));

        glUseProgram(renderer->GetShader());
        glUniformMatrix4fv(
            glGetUniformLocation(renderer->GetShader(), "uModel"),
            1, GL_FALSE, &model[0][0]
        );

        loadedMesh->Draw();

        renderer->DebugCube(meshPos, 0.5f);

        if (pickedTri >= 0)
        {
            int i0 = loadedMesh->indices[pickedTri+0];
            int i1 = loadedMesh->indices[pickedTri+1];
            int i2 = loadedMesh->indices[pickedTri+2];

            glm::vec3 v0 = glm::vec3(model * glm::vec4(loadedMesh->vertices[i0], 1.0f));
            glm::vec3 v1 = glm::vec3(model * glm::vec4(loadedMesh->vertices[i1], 1.0f));
            glm::vec3 v2 = glm::vec3(model * glm::vec4(loadedMesh->vertices[i2], 1.0f));

            renderer->DrawTriangleHighlight(v0, v1, v2);
        }



    }
    if (showNavmesh && navmesh && !navmesh->renderPolys.empty()) {
        glUseProgram(renderer->GetShader());

        glm::mat4 model(1.0f);
        glUniformMatrix4fv(
            glGetUniformLocation(renderer->GetShader(), "uModel"),
            1, GL_FALSE, &model[0][0]
        );

        for (auto& p : navmesh->renderPolys) {
            // cor por área
            glm::vec3 col(0.1, 0.5, 1.0);
            if (p.area == 1) col = glm::vec3(0,1,0);
            if (p.area == 2) col = glm::vec3(1,0,0);

            glUniform3f(glGetUniformLocation(renderer->GetShader(),"uSolidColor"),
                        col.r, col.g, col.b);

            // desenhar
            GLuint vao, vbo, ebo;
            glGenVertexArrays(1,&vao);
            glGenBuffers(1,&vbo);
            glGenBuffers(1,&ebo);

            glBindVertexArray(vao);
            glBindBuffer(GL_ARRAY_BUFFER,vbo);
            glBufferData(GL_ARRAY_BUFFER,
                p.verts.size()*sizeof(glm::vec3),
                p.verts.data(), GL_STATIC_DRAW);

            glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,sizeof(glm::vec3),(void*)0);
            glEnableVertexAttribArray(0);

            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
            glBufferData(GL_ELEMENT_ARRAY_BUFFER,
                p.indices.size()*sizeof(unsigned int),
                p.indices.data(), GL_STATIC_DRAW);

            glDrawElements(GL_TRIANGLES, p.indices.size(), GL_UNSIGNED_INT, 0);

            glDeleteBuffers(1,&vbo);
            glDeleteBuffers(1,&ebo);
            glDeleteVertexArrays(1,&vao);
        }
    }

    // desenhar grid e eixo sempre no modo 99
    glDisable(GL_DEPTH_TEST);   // Gizmos ficam por cima

    renderer->Begin(camera, RenderMode::None); // vai setar modo=99
    renderer->DrawGrid();
    renderer->DrawAxisGizmoScreen(camera, 1600, 900);
    renderer->End();

    glEnable(GL_DEPTH_TEST);


    renderer->End();

    // --- Finalizar ImGui ---
    ImGui::Render();
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

    SDL_GL_SwapWindow(window);
}


